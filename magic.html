<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-input { position: absolute; top: 10px; left: 10px; width: 160px; height: 120px; transform: scaleX(-1); z-index: 2; border: 2px solid #333; border-radius: 8px; opacity: 0.7; }
        #ui { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); color: white; text-align: center; z-index: 2; pointer-events: none; }
        .instruction { background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 20px; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.2); }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; }
        p { margin: 5px 0; font-size: 0.9rem; color: #aaa; }
        .tag { color: #4ff; font-weight: bold; }
    </style>
</head>
<body>

<video id="video-input"></video>

<div id="canvas-container"></div>

<div id="ui">
    <div class="instruction">
        <h1>Gesture Control</h1>
        <p>üñê <b>Open Hand:</b> Flower &nbsp;|&nbsp; ‚úåÔ∏è <b>Victory:</b> Heart &nbsp;|&nbsp; ‚úä <b>Fist:</b> Saturn</p>
        <p>‚òùÔ∏è <b>Point:</b> Sphere &nbsp;|&nbsp; ü§ü <b>Three:</b> Torus &nbsp;|&nbsp; üññ <b>Four:</b> Cube</p>
        <p>üëå <b>Pinch:</b> Change Color &nbsp;|&nbsp; ‚ÜîÔ∏è <b>Move:</b> Rotate & Scale &nbsp;|&nbsp; üåä <b>Wave:</b> Ripple Effect</p>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
/**
 * CONFIGURATION
 */
const PARTICLE_COUNT = 30000;
const PARTICLE_SIZE = 0.15;
const MORPH_SPEED = 0.08;

/**
 * THREE.JS SETUP
 */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.008);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 30;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.getElementById('canvas-container').appendChild(renderer.domElement);

// Enhanced lighting
const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
scene.add(ambientLight);

const pointLight1 = new THREE.PointLight(0x4ff, 1.5, 100);
pointLight1.position.set(25, 25, 25);
scene.add(pointLight1);

const pointLight2 = new THREE.PointLight(0xf4f, 1.5, 100);
pointLight2.position.set(-25, -25, 25);
scene.add(pointLight2);

// Particle System Variables
let geometry = new THREE.BufferGeometry();
let material = new THREE.PointsMaterial({
    size: PARTICLE_SIZE,
    vertexColors: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    transparent: true,
    opacity: 0.85
});

// Attribute Arrays
const positions = new Float32Array(PARTICLE_COUNT * 3);
const colors = new Float32Array(PARTICLE_COUNT * 3);
const currentPositions = new Float32Array(PARTICLE_COUNT * 3);
const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
const velocities = new Float32Array(PARTICLE_COUNT * 3);

// Initialize particles randomly
for (let i = 0; i < PARTICLE_COUNT; i++) {
    const x = (Math.random() - 0.5) * 50;
    const y = (Math.random() - 0.5) * 50;
    const z = (Math.random() - 0.5) * 50;

    positions[i * 3] = x;
    positions[i * 3 + 1] = y;
    positions[i * 3 + 2] = z;

    currentPositions[i * 3] = x;
    currentPositions[i * 3 + 1] = y;
    currentPositions[i * 3 + 2] = z;
    
    velocities[i * 3] = (Math.random() - 0.5) * 0.02;
    velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.02;
    velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;
    
    // Rainbow colors
    const hue = i / PARTICLE_COUNT;
    const color = new THREE.Color();
    color.setHSL(hue, 1.0, 0.5);
    colors[i * 3] = color.r;
    colors[i * 3 + 1] = color.g;
    colors[i * 3 + 2] = color.b;
}

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const particleSystem = new THREE.Points(geometry, material);
scene.add(particleSystem);

/**
 * SHAPE GENERATORS
 */
function getSpherePoint(r) {
    const u = Math.random();
    const v = Math.random();
    const theta = 2 * Math.PI * u;
    const phi = Math.acos(2 * v - 1);
    const x = r * Math.sin(phi) * Math.cos(theta);
    const y = r * Math.sin(phi) * Math.sin(theta);
    const z = r * Math.cos(phi);
    return { x, y, z };
}

function getHeartPoint(scale) {
    const t = Math.random() * Math.PI * 2;
    const u = (Math.random() - 0.5) * 2;
    
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
    const z = u * 8 * (1 - Math.abs(x) / 16);

    return { 
        x: x * scale * 0.05, 
        y: (y - 5) * scale * 0.05, 
        z: z * scale * 0.04 
    };
}

function getSaturnPoint() {
    const r = Math.random();
    if (r > 0.4) {
        return getSpherePoint(8);
    } else {
        const angle = Math.random() * Math.PI * 2;
        const dist = 12 + Math.random() * 8;
        const tilt = Math.PI / 7;
        return {
            x: Math.cos(angle) * dist,
            y: (Math.random() - 0.5) * 0.5 + Math.sin(angle) * dist * Math.sin(tilt) * 0.2,
            z: Math.sin(angle) * dist * Math.cos(tilt)
        };
    }
}

function getFlowerPoint() {
    const k = 5;
    const theta = Math.random() * Math.PI * 2;
    const phi = (Math.random() - 0.5) * Math.PI * 0.7; 
    
    const r = 10 * (0.5 + 0.5 * Math.sin(k * theta)); 
    const x = r * Math.cos(theta) * Math.cos(phi);
    const y = r * Math.sin(theta) * Math.cos(phi);
    const z = 5 * Math.sin(phi);
    return {x, y, z};
}

function getTorusPoint(R = 10, r = 4) {
    const u = Math.random() * Math.PI * 2;
    const v = Math.random() * Math.PI * 2;
    
    const x = (R + r * Math.cos(v)) * Math.cos(u);
    const y = (R + r * Math.cos(v)) * Math.sin(u);
    const z = r * Math.sin(v);
    return { x, y, z };
}

function getCubePoint(size = 15) {
    const face = Math.floor(Math.random() * 6);
    const u = (Math.random() - 0.5) * size;
    const v = (Math.random() - 0.5) * size;
    const half = size / 2;
    
    switch(face) {
        case 0: return { x: half, y: u, z: v };
        case 1: return { x: -half, y: u, z: v };
        case 2: return { x: u, y: half, z: v };
        case 3: return { x: u, y: -half, z: v };
        case 4: return { x: u, y: v, z: half };
        case 5: return { x: u, y: v, z: -half };
    }
}

function getSpiralPoint() {
    const t = Math.random() * Math.PI * 10;
    const r = t * 0.6;
    const h = t * 1.2;
    
    return {
        x: r * Math.cos(t),
        y: h - 18,
        z: r * Math.sin(t)
    };
}

function getDNAPoint() {
    const t = Math.random() * Math.PI * 8;
    const strand = Math.random() > 0.5 ? 0 : Math.PI;
    const r = 6;
    
    return {
        x: r * Math.cos(t + strand),
        y: t * 1.8 - 18,
        z: r * Math.sin(t + strand)
    };
}

function getGalaxyPoint() {
    const angle = Math.random() * Math.PI * 2;
    const armOffset = Math.floor(Math.random() * 3) * (Math.PI * 2 / 3);
    const distance = Math.random() * 15;
    const spread = (Math.random() - 0.5) * 2;
    
    const spinAngle = angle + armOffset + distance * 0.3;
    
    return {
        x: Math.cos(spinAngle) * distance,
        y: spread,
        z: Math.sin(spinAngle) * distance
    };
}

// Function to calculate target positions based on shape name
function setTargetShape(shape) {
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        let p;
        if (shape === 'sphere') p = getSpherePoint(12);
        else if (shape === 'heart') p = getHeartPoint(15);
        else if (shape === 'saturn') p = getSaturnPoint();
        else if (shape === 'flower') p = getFlowerPoint();
        else if (shape === 'torus') p = getTorusPoint(10, 4);
        else if (shape === 'cube') p = getCubePoint(15);
        else if (shape === 'spiral') p = getSpiralPoint();
        else if (shape === 'dna') p = getDNAPoint();
        else if (shape === 'galaxy') p = getGalaxyPoint();
        else p = getSpherePoint(10);

        targetPositions[i * 3] = p.x;
        targetPositions[i * 3 + 1] = p.y;
        targetPositions[i * 3 + 2] = p.z;
    }
}

// Set initial shape
setTargetShape('sphere');

/**
 * WAVE EFFECT
 */
let waveTime = 0;
let waveActive = false;
let waveIntensity = 0;

function applyWaveEffect() {
    if (!waveActive) return;
    
    waveTime += 0.05;
    waveIntensity = Math.max(0, waveIntensity - 0.01);
    
    const posArr = geometry.attributes.position.array;
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const ix = i * 3;
        const dist = Math.sqrt(
            currentPositions[ix] * currentPositions[ix] +
            currentPositions[ix + 1] * currentPositions[ix + 1]
        );
        const wave = Math.sin(dist * 0.15 - waveTime) * 3 * waveIntensity;
        posArr[ix + 2] += wave;
    }
    
    if (waveIntensity <= 0.01) waveActive = false;
}

/**
 * MEDIAPIPE HAND TRACKING
 */
const videoElement = document.getElementById('video-input');
let activeShape = 'sphere';
let hue = 0;
let previousHandY = 0.5;

function onResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];

        // Gesture Recognition
        const isFingerUp = (tipIdx, pipIdx) => landmarks[tipIdx].y < landmarks[pipIdx].y;
        
        let fingersUp = 0;
        if (isFingerUp(8, 6)) fingersUp++;    // Index
        if (isFingerUp(12, 10)) fingersUp++;  // Middle
        if (isFingerUp(16, 14)) fingersUp++;  // Ring
        if (isFingerUp(20, 18)) fingersUp++;  // Pinky
        
        // Thumb check
        const thumbOpen = Math.abs(landmarks[4].x - landmarks[3].x) > 0.05;
        if (thumbOpen) fingersUp++;

        // Shape switching based on finger count
        let newShape = activeShape;
        if (fingersUp === 0) newShape = 'saturn';        // Fist
        else if (fingersUp === 1) newShape = 'sphere';   // Point
        else if (fingersUp === 2) newShape = 'heart';    // Victory
        else if (fingersUp === 3) newShape = 'torus';    // Three fingers
        else if (fingersUp === 4) newShape = 'cube';     // Four fingers
        else if (fingersUp === 5) newShape = 'flower';   // Open hand
        
        if (newShape !== activeShape) {
            activeShape = newShape;
            setTargetShape(activeShape);
        }

        // Pinch Detection for color cycling
        const dx = landmarks[4].x - landmarks[8].x;
        const dy = landmarks[4].y - landmarks[8].y;
        const pinchDist = Math.sqrt(dx*dx + dy*dy);
        
        if (pinchDist < 0.05) {
            hue += 0.02;
            if (hue > 1) hue = 0;
            
            const colorsArr = geometry.attributes.color.array;
            for(let i=0; i<PARTICLE_COUNT; i++){
                const particleHue = (hue + (i / PARTICLE_COUNT) * 0.2) % 1;
                const color = new THREE.Color();
                color.setHSL(particleHue, 1.0, 0.5);
                colorsArr[i*3] = color.r;
                colorsArr[i*3+1] = color.g;
                colorsArr[i*3+2] = color.b;
            }
            geometry.attributes.color.needsUpdate = true;
        }

        // Hand Position Mapping (Rotation & Scale)
        const cx = landmarks[9].x;
        const cy = landmarks[9].y;
        
        const targetRotY = (cx - 0.5) * Math.PI * 2;
        const targetRotX = (cy - 0.5) * Math.PI;

        particleSystem.rotation.y += (targetRotY - particleSystem.rotation.y) * 0.1;
        particleSystem.rotation.x += (targetRotX - particleSystem.rotation.x) * 0.1;
        
        const handSize = Math.abs(landmarks[0].y - landmarks[12].y);
        const targetScale = 1 + (handSize * 2);
        
        particleSystem.scale.setScalar(THREE.MathUtils.lerp(particleSystem.scale.x, targetScale, 0.1));
        
        // Wave detection (rapid vertical hand movement)
        const handVelocityY = Math.abs(cy - previousHandY);
        previousHandY = cy;
        
        if (handVelocityY > 0.03) {
            waveActive = true;
            waveIntensity = Math.min(1, waveIntensity + 0.2);
        }
    }
}

// MediaPipe Setup
const hands = new Hands({locateFile: (file) => {
  return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.5,
  minTrackingConfidence: 0.5
});

hands.onResults(onResults);

// Camera Setup
const cameraUtils = new Camera(videoElement, {
  onFrame: async () => {
    await hands.send({image: videoElement});
  },
  width: 640,
  height: 480
});
cameraUtils.start();

/**
 * ANIMATION LOOP
 */
function animate() {
    requestAnimationFrame(animate);

    // Morphing Logic
    const posAttribute = geometry.attributes.position;
    const posArr = posAttribute.array;

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const ix = i * 3;
        const iy = i * 3 + 1;
        const iz = i * 3 + 2;

        // Smooth morphing
        currentPositions[ix] += (targetPositions[ix] - currentPositions[ix]) * MORPH_SPEED;
        currentPositions[iy] += (targetPositions[iy] - currentPositions[iy]) * MORPH_SPEED;
        currentPositions[iz] += (targetPositions[iz] - currentPositions[iz]) * MORPH_SPEED;

        // Dynamic wobble
        const time = Date.now() * 0.001;
        posArr[ix] = currentPositions[ix] + Math.sin(time + i * 0.1) * 0.06;
        posArr[iy] = currentPositions[iy] + Math.cos(time * 1.2 + i * 0.1) * 0.06;
        posArr[iz] = currentPositions[iz] + Math.sin(time * 0.8 + i * 0.1) * 0.04;
    }

    posAttribute.needsUpdate = true;
    
    // Apply wave effect
    applyWaveEffect();
    
    // Animate lights for dynamic effect
    const lightTime = Date.now() * 0.0005;
    pointLight1.position.x = Math.sin(lightTime) * 25;
    pointLight1.position.z = Math.cos(lightTime) * 25;
    pointLight2.position.x = Math.cos(lightTime * 1.3) * 25;
    pointLight2.position.z = Math.sin(lightTime * 1.3) * 25;

    renderer.render(scene, camera);
}

// Window Resize Handling
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();

</script>
</body>
</html>